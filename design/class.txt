@startuml

scale 1.5

class "Trajectory" {
    +double xv_, yv_, thetav_
    +double cost_
    +double time_delta_
    -vector<double> x_pts_, y_pts_, th_pts_
    +void getPoint(uint index, double& x, double& y, double& z, double& th)
    +void setPoint(uint index, double& x, double& y, double& z, double& th)
    +void addPoint(double& x, double& y, double& th)
    +void getEndPoint(double& x, double& y, double& th)
    +void resetPoints()
    +uint getPointSize()
}
note top: ãOê’Çä«óùÇ∑ÇÈÉNÉâÉX

class goal_functions as "goal_functions.h" {
    +double getGoalPositionDistance(const PoseStamped& global_pose,\n\t\t\tdouble goal_x, double goal_y)
    +double getGoalOrientationAngleDifference(const PoseStamped& global_pose,\n\t\t\tdouble goal_th)
    +void publishPlan(const vector<PoseStamped>& path, const Publisher& pub)
    +prunePlan(const PoseStamped& global_pose,\n\t\t\t\tvector<PoseStamped>& plan,\n\t\t\t\tvector<PoseStamed>& global_plan)
    +bool transformGlobalPlan(const Buffer& tf,\n\t\t\tconst vector<PoseStamed>& global_plan,\n\t\t\tconst PoseStamed& global_robot_pose,\n\t\t\tconst Costmap2D& costmap,\n\t\t\tconst string& global_frame,\n\t\t\tvector<PoseStamped>& transformed_plan)
    +getGoalPose(const Buffer& tf,\n\t\tconst vector<PoseStamped>& global_plan,\n\t\tstring& global_frame,\n\t\tPoseStamped& goal_pose)
    +isGoalReached(const Buffer& tf,\n\t\tconst vector<PoseStamped>& global_plan,\n\t\tconst Costmap2D& costmap,\n\t\tconst string& global_frame,\n\t\tconst Odometry& base_odom,\n\t\tdouble rot_stopped_vel,\n\t\tdouble trans_stopped_vel\n\t\tdouble xy_goal_tolerance,\n\t\tdouble yaw_goal_tolerance)
    +bool stopped(const Odometry& base_odom,\n\t\tconst double& rot_stopped_velocity,\n\t\tconst double& trans_stopped_velocity)
}

class "MapCell" {
    +uint cx, cy
    +double target_dist
    +bool target_mark
    +bool within_robot
}

class "BaseGlobalPlanner" {
    +bool makePlan(const PoseStamped& start,\n\t\tconst PoseStamped& goal,\n\t\tvector<PoseStamped>& plan)
    +bool makePlan(const PoseStamped& start,\n\t\tconst PoseStamed& goal,\n\t\tvector<PoseStamped>& plan,\n\t\tdouble& cost)
    +void initialize(string name, Costmap2DROS* costmap_ros)
}

class "BaseLocalPlanner" {
    +bool computeVelocityCommands(Twist& cmd_vel)
    +bool isGoalReached()
    +bool setPlan(const vector<PoseStamped>& plan)
    +initialize(string name, Buffer* tf, Costmap2DROS* costmap_ros)
}

class "CostmapModel" {
    +double footprintCost(const Point& position, const vector<Point>& footprint,\n\t\tdouble inscribed_radius, double circumscribed_radius)
    +double lineCost(int x0, int x1, int y0, int y1)
    +double pointCost(int x, int y)
    -Costmap2D& costmap_
}

class "MapGrid" {
    +inline MapCell& operator() (uint x, uint y) const
    +inline MapCell operator() (uint x, uint y)
    +inline MapCell& getCell(uint x, uint y)
    +MapGrid& operator= (const MapGrid& mg)
    +void resetPathDist()
    +void sizeCheck(uint size_x, uint size_y)
    +void commonInit()
    +size_t getIndex(int x, int y)
    +inline double obstacleCosts()
    +inline double unreachableCellCosts()
    +inline bool updatePathCell(MapCell* current_cell, MapCell* check_cell, const Costmap2D& costmap)
    +static void adjustPlanResolution(const vector<PoseStamped>& global_plan_in,\n\t\tvector<PoseStamped>& global_plan_out,\n\t\tdouble resolution)
    +void computeTargetDistance(queue<MapCell*>& dist_queue, const Costmap2D& costmap)
    +void computeGoalDistance(queue<MapCell*>& dist_queue, const Costmap2D& costmap)
    +void setTargetCells(const Costmap2D& costmap, const vector<PoseStamped>& global_plan)
    +void setLocalGoal(const Costmap2D& costmap, const vector<PoseStamped>& global_plan)
    +double goal_x_, goal_y_
    +uint size_x_, size_y_
    -vector<MapCell> map_
}

@enduml